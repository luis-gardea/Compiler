user: lgardea
user: rdsilva

README file for Programming Assignment 2 (C++ edition)
======================================================

Write-up for PA2
----------------

For our design decisions, beginning with the implementation of the list of features, which could be empty but could not have empty features, we wrote a general one that could either be empty or would lead to a feature_list_prime that could not be empty, in order to eliminate some ambiguities; the same was done for the list containing formals and the list containing expressions. Feature and formal themselves were written in a straightforward way, much as they are shown in the COOL manual. Block expressions also required a type declaration as a list of expressions as did the list of case expressions. Let statements were nested within each other and the last return value for each was either the return value of the IN expression at the end or the value of the let statement nested within it; in order to avoid ambiguities, we set precedence on each of the possible statements, which removed any potential shift/reduce errors. Finally, all of the expression productions were also written in the same way that they were defined in the COOL manual.

For our error checking, we focused on what the assignment handout said. We handled class errors (subsequent classes can be read if terminated correctly), we handled errors in features (going on to the next feature), we handled errors in a let binding (going on to next variable), and we handled errors inside of an expression block. The way we handled class errors was just by using the error token and then finishing throwing text away when ';' is encountered. For features, because feature_list can be empty and in order to not have shift/reduce errors, the error handling was done in feature_list_prime; this is important because we do not want to have empty features and so if a feature is not correct in the list or by itself, the error token is called and text is removed until ';' is read. For block expressions, a similar thing was done since we do not want empty block expressions; once the error token is read, text is removed until ';' is read. For our let statements, we handled the error case where the error happens before a comma, which is then followed by another let expression, and we also handled the case where the error happened just before the IN expression part of the let statement. Another error case that we handled happened within expressions, when there is erroneous input between IF and FI.

We designed a testing script written in python to carry out the testing for us. We had options to test a single file on our parser or an entire folder of tests we had created in the folder /tests located in PA2. We compared output of the reference parser using a diff on the 2 output files created by our parser and the reference. 

We started tetsing by making good programs with tricky edge cases, specifically to test the let expression for ambiguity resolution. We tested nested let and if/else statements with a variety of valid programs. Next we tested bad programs, specifically we threw a multitude of tests at our parsing testing errors in classes, features, let statements, and block expressions. We also pseudo-fuzz-tested our precedence and associativity rules with crazy expressions involving operators.Finally we tested on the given test files on the farmshare.